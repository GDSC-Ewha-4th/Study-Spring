### 1. JPA 프로그래밍에 들어가기 이전에..

JPA의 필요성: 과거에는 객체를 데이터베이스를 저장하고 찾으려면, API와 sql을 직접 적었어야함.

JPA는 sql을 작성할 필요가 없다.

public class MemberDAO{
    @PersistenceContext
    EntityManager jpa;

    public void save(Member member){
        jpa.persist(member); //단순하게 jpa 이용 가능, 개발자 대신에 sql 실행
    }
    
    public Member findOne(Long id){
        retrun jpa.find(Member.class, id);
    }

}

Sql을 한땀 한땀 작성하는 것보다 훨씬 생산성을 높이고, 유지보수와 속도 측면에서 이전과는 확연하게 차이가 남.

JPA에서 가장 중요한 것 : 객체와 테이블을 '잘' 매핑해야 함

- 목표: 객체와 테이블 설계 매핑! , JPA가 내부적으로 **어떻게 동작하는 지** 정확하게 이해하기!

복잡한 관계에서 JPA를 어떻게 매핑해야 하는지를 배워갈 예정임!

학습 방법 - 이론과 라이브 코딩! 

실전 예제!! 

### 2. ﻿JPA 소개 (첫시간이 가장 중요함!)

2-1 SQL 중심적인 개발의 문제점

관계형 DB에 저장해야 함! - 관계형 DB에서는 SQL을 계속 작성해야함. 

무한 반복과 지루한 코드!  - CURD의 반복

1. 문제 
- 기획자가 회원을 설계 해달라고 해서 DB를 짜면, 객체를 짜고, Query를 작성하는데, 만일 변경사항이 생기면 처음부터 끝까지 다 수정해야함 => 관계형 DB를 써야할 때는 SQL에 의존적인 개발을 피하기가 어려움

- 패러다임의 불일치 : 객체지향 프로그래밍과 관계형 DB의 성질이 다르다. 객체를 저장한다고 생각해보면 다양한 저장소에 저장할 수 있지만,  현실적인 대안은 관계형 DB임 ,

**객체와 관계형 DB의 차이때문에 DB에 저장할 때 힘듬.** 

상속 관계에서의 차이점

상속관계를 DB에서 구현하려면 Table의 슈퍼타입과 서브타입 관게로 넣음. 

객체 생성 코드를 작성한 후 DB에 저장하려고 하면 인서트 코드를 두번 써야함. (조회도 엄청 어려움)

DB가 아니고 자바 컬렉션에 조회한다고 하면? 되게 간단해지고 쉬워짐. 

**관계형 DB에 넣고 빼내는 순간 복잡해진다.**

연관관계

객체는 참조를 사용, 테이블은 외래 키를 사용함.

차이점 : 객체는 참조하는 테이블에만 접근할 수 있지만 테이블에서는 외래키를 통해 반대로도 Join할 수 있음 

객체에서는 참조로 연관관계를 맺는다.  => sql문에서 foreign 값 사용

객체 모델링을 조회할 때는?  조인을 한다음에 관계를 설정하고 객체를 반환해줌 .

객체 모델링도 자바 컬랙션에 넣는다.

객체 그래프 탐색

객체는 객체 그래프를 탐색할 수 있어야한다. 

처음 실행하는 SQL에 따라 탐색 범위를 결정함. => 처음에 결정한 값이 아니면 값을 못 꺼낸다. 

인티티 신뢰 문제가 발생할 수 있음 . 쿼리와 조립을 눈으로 확인하지 않는 이상은 반환된 엔티티를 신뢰할 수가 없음!

의존성이 좋지 않음

모든 객체는 미리 로딩할 수는 없다 : 상황에 따라 동일한 회원 조회 메서드를 여러벌 생성 

개발자가 SQL을 직접 작성하게 되면 계층 분할이 어려움

자바 컬랙션에서 조회하고 객체를 두번 꺼낸다고하면, 참조값을 비교하면 같다고 나옴. SQL에서는 다르다(두번 리턴되기 때문에) 

객체답게 모델링을 할수록 매핑 작업만 늘어난다..

자바 컬렉션에 저장하듯이 DB에 저장하는게 JPA이다!

2-2. JPA 소개 

ORM - 객체 관계 매핑: 객체는 객체대로 설게하고 관계형 데이터베이스는 관계형 데이터베이스대로 설계한 다음 ORM 프레임워크가 중간에서 매핑해준다.)

JPA는 애플리케이션과 JDBC 사이에서 동작한다.

JAVA 애플리케이션에서 개발자가 JPA에 명령을 하면 JDBC API를 사용해 SQL을 호출하고 DB에서 결과를 반환받는다

JPA의 동작 -

저장 

객체를 넘김 = JPA가 객체를 분석하고 적절한 insert 쿼리를 생성하고 JDBC API를 사용해서 DB와 통신한다. 

조회

JPA가 멤버 정보를 보고 SELECT 쿼리 만듬.  Result 매핑을 해줌

JPA가 뭘까? 

JPA는 표준 명세 => 인터페이스의 모음 

JPA는 왜 사용해야 하는가?

생산성 측면 - 코드가 다 만들어져있기 때문에 편하게 개발할 수 있음.

수정이 환상적임!

Member.setName("변경한 이름") //원하는 값을 넣으면 이름이 바껴서 DB 업데이트 쿼리가 생성

 유지보수 측면 

기존에는 필드 변경시 모든 SQL문을 수정했어야 함.

JPA를 사용하면, 그냥 column만 추가하면 됨.

**JPA 패러다임의 불일치를 해결해 줌**  

상속 관계

개발자가 jpa.persist 코드를 짜면 나머지는 JPA가 처리해 줌 => Insert문을 JPA가 두개로 만들어서 처리해줌. 상속되는 것과, 상속을 해주는 쿼리를 다 JPA가 코드를 짜줌.

조회할 때도, find 코드를 넘기면 JPA가 조인을 한 후 가지고 옴.

JPA와 연관관계, 객체 그래프 탐색

개발자가 연관관계를 저장하면 JPA가 어렵지 않게 객체 그래프를 탐색함.

신뢰할 수 있는 엔티티, 계층 => 기존에서는 객체 그래프를 신뢰할 수 없었는데, JPA가 있으면 자유롭게 객체 그래프를 탐색할 수 있음. 

JPA에서는 동일한 트랜잭션에서 조회한 엔티티는 같음을 보장한다.

JPA를 사용하면 성능이 떨어지지 않을까?  

JPA의 성능 최적화 기능 

1. 1차 캐시와 동일성 보장 => 캐싱 기능 같은 트랜잭션 안에서는 같은 엔티티를 반환한다.(SQL 1번만 실행) 약간의 조회 성능 향상 

2. 트랜잭션을 지원하느 쓰기 지연 -

기존 : INSERT 트랜잭션을 커밋할 때까지 INSERT SQL을 모음.

JPA를 사용하면? : 옵션을 키면 쿼리들을 하나씩 모아서 커밋되기 전에 한번에 보냄 . 

3. 즉시 로딩과 지연 로딩 

*중요한 부분 

- 지연 로딩:    
  
  - memberDAO를 통해서 멤버 객체를 꺼냈으면, 멤버만 먼저 나옴.
  
  - member.getTeam()에서 팀 객체를 가져오고 데이터를 채워서 채워진 결과를 반환해 줌

- 즉시 로딩:
  
  지연 로딩에서 쿼리가 너무 많기 때문에, 조회할 때 바로 조인해서 member를 조회할 때 무조건 team을 가져옴 . 옵션을 조정해서 바로 튜닝이 가능함. 
  
  

ORM은 객체와 RDB 두 기둥위에 있는 기술

- JPA와 RDB(관계형 데이터 베이스) 둘 다 잘해야 함!! 
  
  

## JPA 시작하기& 영속성

https://olaffromdoh.tistory.com/
