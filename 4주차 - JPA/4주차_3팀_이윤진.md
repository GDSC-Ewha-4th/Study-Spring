**프록시**

실제 클래스 상속받아 사용

실제 클래스와 겉 모양이 같다.

사용하는 입장에서 진짜 객체인지 프록시 객체인지 구분하지 않고 사용

프록시 객체는 실제 객체의 참조(target)를 보관

프록시 객체 호출하면 프록시 객체는 실제 객체의 메소드 호출

**프록시의 특징**

프록시 객체는 처음 사용할 때 한 번만 초기화

프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아님, 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근 가능

프록시 객체는 원본 엔티티를 상속받음, 따라서 타입 체크시 주의해야함 (== 비교 실패, 대신 instance of 사용)

영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티 반환

영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화하면문제 발생(하이버네이트는 org.hibernate.LazyInitializationException 예외를 터트림)

**프록시 확인**

- 프록시 인스턴스의 초기화 여부 확인
- 프록시 클래스 확인 방법
- 프록시 강제 초기화

즉시로딩과 지연로딩

- 지연 로딩 최대한 사용하기
- @ManyToOne, @OneToOne은 기본이 즉시 로딩→ LAZY로 설정

영속성 전이 : CASCADE

특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들도 싶을 때 사용함

CASCADE 종류

ALL : 모두 적용

PRESIST : 영속

REMOVE : 삭제

MERGE: 병합

임베디드 타입 새로운 값 타입을 직접 정의할 수 있음 JPA는 임베디드 타입임

임베디드 타입 장점

**재사용, 높은 응집도**

값 타입 비교

- 동일성 비교 : 인스턴스 참조 값 비교,== 사용
- 동등성 비교 : 인스턴스 값 비교, equals()사용
- 값타입에서 동등성 비교 중요

값 타입 컬렉션의 제약사항

- 값 타입은 엔티티와 다르게 식별자 개념이 없다
- 값은 변경하면 추적이 어렵다.
- null 입력 X, 중복 저장 X

**JPQL**

JPA를 사용하면 엔티티 객체를 중심으로 개발

테이블이 아닌 엔티티 객체를 대상으로 검색

모든 DB 데이터를 객체로 변환해서 검색하는 것은 불가능

JPQL과 실행된 SQL

**JPQL 문법**

- 엔티티와 속성은 대소문자 구부함
- JPQL 키워드는 대소문자 구분x
- 별칭은 필수임
- 엔티티 이름 사용, 테이블 이름 아님

**조인**

- 내부조인 INNER JOIN
- 외부조인 LEFT OUTER JOIN

ON 절

- 조인 대상 필터링
- 연관관계 없는 엔티티 외부 조인

서브쿼리

쿼리 내에 쿼리를 또 작성한다.

한계 → JPA는 WHERE, HAVING 절에서만 서브쿼리 사용가능한다, FROM 절의 서브쿼리는 현재 JPQL에서 불가능함

조건식 - CASE식

- COALESCE : 하나씩 조회해서 null이 아니면 반환함

객체지향 쿼리 언어2 - 중급 문법

경로 표현식

점을 찍어 그래프 탐색하는 것

- Member의 username 으로 객체 그래프 탐색
- 어떤 필드에 접근하는지 지정해줌
- 상태 필드 : 단순 값 저장하기 위한 필드
- 연관 필드 : 연관관계 위한 필드
- 단일 값 연간 필드 : @ManyToOne, @OneToOne, 묵시적 내부 조인 발생, 탐색o
- 컬렉션 값 연관 필드 : @OneToMany, @ManyToMany, 묵시적 내부 조인 발생, 탐색x

**명시적 조인, 묵시적 조인**

- 명시적 조인 : join 키워드 직접 사용
- 묵시적 조인 : 경로 표현식에 의해 묵시적으로 SQL 조인 발생 (내부 조인 발생함)

(묵시적 조인 최대한 쓰지말기, 조인은 SQL 튜닝에 중요한 포인트임)

**JPQL - 패치 조인**

- SQL 조인 종류X
- JPQL에서 성능 최적화를 위해 제공하는 기능
- 연관된 엔티티나 컬렉션을 SQL 한 번에 함께 조회하는 기능

**엔티티 페치 조인**

- 회원을 조회하면서 연관된 팀도 함께 조회함

**페인조인과 DISTINCT**

- SQL의 DISTINCT는 모든 중복된 결과를 제거할 수 없음
- JPAL의 DISTINCT 기능 사용
- SQL에 DISTINCT 추가 가능
- 애플리케이션 엔티티 중복 제거 할 수 있음

**패치 조인과 일반 조인의 차이**

- 일반 조인은 실행했을 떄 연관된 엔티티 함께 조회하지 않음
- 패치조인 사용하면 연관된 엔티티도 함께 조인 (즉시 로딩)
- 패치 조인 → 객체 그래프를 SQL 통해 한번에 조회하는 것

**패치 조인의 한계**

- 패치 조인에 별칭 줄 수 없다.
- 둘 이상의 컬렉션은 페치 조인 불가능

**패치 조인의 특징**

- 연관된 엔티티들 SQL 한번으로 조회 가능
- 패치 조인 우선권 갖음
- 최적화 필요한 곳에서 사용함

**엔티티 직접 사용**

JPQL

select count(m.id) from Member m //엔티티의 아이디를 사용select count(m) from Member m //엔티티를 직접 사용

select count([m.id](http://m.id/)) as cnt from Member m → 둘다 같은 **SQL 실행**

파라미터로 member 넘기거나 직접식별자 ID 넘겨도 동일한 SQL 출력함

**Named 쿼리 - 정적 쿼리**

미리 정의해서 이름 부여해두고 사용하는 JPQL임

애플리케이션 로딩 시점에 초기화 후 재사용함

애플리케이션 로딩 시점에 쿼리를 검증
