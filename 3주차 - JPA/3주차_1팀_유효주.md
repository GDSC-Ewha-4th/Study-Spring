# 4,5,6,7강

# 4강

### 객체와 테이블 매핑

- @Entity가 붙은 클래스는 JPA가 관리하는 엔티티임 안붙은 건 그냥 내가 마음대로 쓰는 클래스
- 주의

      기본 생성자 필수 

      final클래스나 enum, interface,inner 클래스는 사용 @Entity를 사용할 수 없음

 

- name이라는 속성 사용 가능 기본값이 현재 있는 클래스의 이름과 동일한 걸 사용 다른 패키지에 같은 이름의 클래스가 있을때 사용

### 데이터베이스 스키마 자동 생성

- jpa는 맵핑 정보만 보면 어떤 쿼리를 만들어야하는지 , 어떤 테이블을 만들어야하는 지 알 수 있음
- 애플리케이션 로딩 시점에 디비 테이블을 생성하는 기능을 지원해줌
- 물론 이런 건 운영에서 사용하면 안됨 내가 로컬에서 개발할 때 도움이 됨

- 애플리케이션 로딩 시점에 create문으로 일단 DB를 생성하고 시작할 수 있음
    - 장점 : 개발할 때 보통 테이블을 먼저 만들어놓고 그 다음에 객체 돌아서 개발하는데 jpa는 그럴 필요가 없음
    - 객체 맵핑을 다 해놓으면 애플리케이션을 쓸 때 필요하면 테이블을 다 만들어줌
    - 데이터베이스 방언을 활용해서 데이터베이스에 맞는 적절한 DDL을 생성해줌
    
    ### 운영 장비에는 절대 create, create-drop,update를 사용하면 안된다.
    
    - 개발 초기 단계는 create 또는 update
    - 테스트 서버는 update  또는 validate
    - 스테이징과 운영 서버는 validate 또는  none
    
    ### 필드와 컬럼 매핑
    
    ```java
    @Column(name ="name") // name이라고 속성 
    private String username; //객체는 username이라고 쓰고 DB에는 name이라고 쓰고 싶을 때 사용
    ```
    
    @Column
    
    - insertable,updatable
        - column을 수정했을 때 DB에 insert를 할꺼냐 말꺼냐
        - 기본값 : TRUE
    - nullable(DDL)
        - null 값의 허용 여부를 설정함 false로 설정하면 DDL 생성 시에 NOT NULL 제약조건이 붙는다.
    
    @Enumerated
    
    - `EnumType.ORDINAL` : DEFAULT가 이 값임 기본적으로 INTEGER값이 들어감
        - 기본을 쓰면 안되는 이유 : 만약  roletype에 GUEST를 추가해달라는 요구사항이 들어옴 , 그래서 추가했는데 ORDINAL로 했는데 멋대로 순서가 바뀔 수도 있음 그래서 `enum.STRING`으로 써야함 그럼 문자로 들어가게 됨 ‘GUEST’로 들어감
    
    @Temporal
    
    ```java
    private LocalDate testLocalDate;
    private LocalDateTime testLocalDateTime;
    ```
    
    Lob은 지정할 수 있는 타입이 없음  필드 타입이 문자면 CLOB 매핑 , 나머지는 BLOB 매핑
    
     
    
    ### 기본키 매핑
    
- **직접 할당 :@Id만 사용**

- **자동 생성: @GeneratedValue  (값을 자동으로 할당해줌)**
    1. IDENTITY : 데이터베이스에 위임 , MYSQL의 autoincrement순차적으로 DB가 값을 넣어줌(난 모르겠고 DB야 너가 알아서 해줘)
    2. SEQUENCE : 데이터베이스 시퀀스 오브젝트 사용 ,  ORACLE같은 데이터베이스에서 주로 사용
    
           - SequenceGenerator 필요 ,
    
      3. TABLE: 키 생성용 테이블 사용 , 모든 DB에서 사용
    
           - TableGenerator 필요
    
      4. AUTO: 방언에 따라 자동 지정, 기본값
    
    ```java
    @GeneratedValue(Strategy = GenerationType.AUTO)
    ```
    

- IDENTITY 전략 - 특징
    1. 기본 키 생성을 데이터베이스에 위임 - DB가 알아서 해줌
    2. IDENTITY는 DB에 넣어봐야 값을 INSERT 쿼리로 날려봐야 그떼 PK값을 알 수 있기때문에 얘는 일단 persist()때 바로 insert 쿼리가 들어감 내가 id값을 모르니까 ,원래는 commit()때 들어가야하는데
    3. 그래서 모아서 insert하는게 identity전략에서는 힘듦

```java
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private String id;
```

```java
@Entity 
@SequenceGenerator( 
 name = “MEMBER_SEQ_GENERATOR", 
 sequenceName = “MEMBER_SEQ", //매핑할 데이터베이스 시퀀스 이름
 initialValue = 1, allocationSize = 1) 
public class Member { 
 @Id 
 @GeneratedValue(strategy = GenerationType.SEQUENCE, 
 generator = "MEMBER_SEQ_GENERATOR") 
 private Long id;
```

- SEQUENCE 전략
    1. ORACLE에서 많이 사용
        
        sequence object가 1부터 시작하고 1씩 증가시키라고 세팅함
        
    2. SEQUENCE는 한번에 모아서 쿼리 날리는 게 가능함
        1. 자꾸 next call로 가져오면 계속 네트워크를 타기때문에 성능 문제가 발생할 수도 있는데 이걸 최적화하려고 미리 50개를 땡기는거임 next call 한 번할 때 미리 50개 사이즈를 DB에 올려놓고 메모리는 1씩 보는거임 어 ? 다 봤네하면 또 next call을 하는거지 미리 DB에 올려놓고 메모리에서 그 개수만큼 쓰는거임 이러면 여러 웹서버가 있어도 동시성 이슈 없이 다양한 문제를 해결할 수 있음 
        
        ```java
        em.persist(member1) //1 , 51 이때만 next call
        em.persist(member2) //mem
        em.persist(member3) //mem
        ```
        

- TABLE 전략

```java
@Entity 
@TableGenerator( 
 name = "MEMBER_SEQ_GENERATOR", 
 table = "MY_SEQUENCES", 
 pkColumnValue = “MEMBER_SEQ", allocationSize = 1) 
public class Member { 
 @Id 
 @GeneratedValue(strategy = GenerationType.TABLE, 
 generator = "MEMBER_SEQ_GENERATOR") 
 private Long id;
```

운영에서 쓰는 건 조금 부담스러움. 잘 쓰지는 않음

DB에서 관례로 쓰는 것들이 있기때문에 걔를 쓰는 것을 권장함

- 권장하는 식별자 전략
    - 기본 키 제약 조건 : null아님 , 유일 , 변하면 안된다
    - 미래까지 이 조건을 만족하는 자연키는 찾기 어렵다. 대리킨(대체키)를 사용하는 걸 권장
    - 주민등록번호도 기본 키로 적절하지 않음 - join하는 테이블들이 많으면
    - 권장 : Long형 + 대체키 + 키 생성전략 사용
    - AUTO_INCREMENT나 sequence_object  둘 중 하나를 쓰고 랜덤값을 쓰거나

# 5강

JPA에서는 객체의 참조와 DB의 외래키를 매핑해서 연관관계를 매핑할 수 있음

### 양방향 연관관계와 연관관계의 주인

- 사실상 테이블의 연관관계에는 방향이라는게 없음
- 객체의 참조는 방향이 있어서 Team에서 Member로 갈 수가 없음 그래서 `List members`를 넣어줌(Member에서 Team은 다대일 관계임)
- 연관관계의 주인과 `mappedBy`
    - 객체와 테이블이 관계를 맺는 차이
    - 객체 연관관계 : 단방향(팀 → 멤버 , 멤버 →팀)이 2개 있음
    - 테이블 연관관계: MEMBER의 TEAM_ID(FK)로 TEAM의 TEAM_ID(PK)와 join을 하면 member가 어느 팀 소속인지 알 수 있음

member를 바꾸고 싶거나 새로운 team에 들어가고 싶을 때 Member의 Team team값을 바꿔야할지, Team에 있는 List members 값을 바꿔야할지 ,,,,, DB입장에서는 MEMBER 테이블의 TEAM_ID(FK) 값만 업데이트되면 됨 

- 둘 중 하나로 외래키를 관리해야함 Team team으로 할지 , List members로 할지
- 연관관계의 주인만이 외래 키를 관리할 수 있음(등록,수정)
- 주인은 `mappedBy` 속성을 사용하지 못함( 뭐에 의해서 매핑이 된다는 의미니까 주인은 사용할 수 없음)

그럼 누구를 주인으로 할꺼냐? **외래 키가 있는 곳을 주인으로 정해라**

→여기서는 Member.team이 연관관계의 주인임 , MEMBER 테이블에 TEAM_ID 외래 키가 있으니까 

→ DB입장에서 보면 외래 키가 있는 곳이 무조건 다(many)임 외래 키가 없는 곳이 일(one)임  n쪽이 무조건 연관관계의 주인임

### 양뱡향 매핑시 가장 많이 하는 실수

→ 연관관계의 주인에 값을 입력하지 않음

```java
@OneToMany(mappedBy="Team")
private List<Member> members = new ArrayList<>();
```

이건 읽기 전용임  JPA에서 update를 하거나 insert할 때는 이걸 아예 안봄

그래서 연관관계의 주인에 값을 설정해줘야함

```java
member.setTeam(team); 
//두개 다 설정할 수도 있음
team,getMembers().add(member); //-(1)
//어차피 jpa에서 위의 값은 읽기 전용이기때문에 이 값을 쓰지는 않음
```

### **양방향 매핑을 할 때는 양쪽에 다 값을 넣어주는 게 맞음(객체지향적으로 생각을 하면)**

- (1)처럼 안하고 em.flush(); , em.clear();를 해버리면 문제는 없으나
- (1차 캐시에 넣어놓은 상태에서 )조회를 하면 순수한 객체 상태(아무것도 없는 빈 상태)로 해당 컬렉션에는 아무것도 없는 상태인거임
- 테스트 케이스 작성할 때는 순수한 자바 상태로 작성을 하는데 member.getTeam();은 되는데 반대로 하면  null이나 이상한 값이 나올 수 있음
- flush하고 clear하면 괜찮은 이유가 1차 캐시에 아무것도 없기 때문에 DB에서 다시 조회해옴

**→순수 객체 상태를 고려해서 항상 양쪽에 값을 설정하자**

- 연관관게 편의 메서드 (Member에서)

```java
public void setTeam(Team team){
   this.team = team;

   team.getMembers().add(this);//여기서 this가 나 자신(Member)임 
                               //나 자신의 인스턴스를 넣어줌
}
```

강사는 set을 잘 쓰지는 않고 change를 자주 씀 

setTeam → changeTeam

- 양방향 매핑시에 무한 루프를 조심하자
    - toString(), lombok, JSON 라이브러리
        - lombok에서 toString() 만드는 것은 웬만하면 쓰지마라
        - 컨트롤러에서는 dto라고 단순하게 값만 있는 변환해서 반환하는 걸 추천 그러면 JSON에서 문제가 생길 일은 없음 웬만하면 컨트롤러에서 엔티티를 반환하지 마셈

### 양방향 매핑 정리

- **단방향 매핑만으로도 이미 연관관계 매핑은 완료**
    - 처음에 설계할 때, 일단 단방향 매핑으로 설계를 완료를 해야함
- 양방향 매핑은 반대 방향으로 조회(객체 그래프 탐색) 기능이 추가된 것 뿐
    - 객체 입장에서는 양방향이 일만 복잡해질뿐임
    - 역방향으로 참조할 일이 생길 때 사용
- JPQL에서 역방향으로 탐색할 일이 많음
- 테이블에 영향을 주지는 않기 때문에 작업하다가 필요하면 추가해라

**연관관계의 주인을 정하는 기준**

- 비즈니스 로직을 기준으로 연관관계의 주인을 선택하면 안됨
- **연관관계의 주인은 외래 키의 위치를 기준으로 정해야함**

**실전예제-2**

- 케바케지만 대부분의 경우에 Member에 orders를 넣는 게 좋은 설계는 아님 테이블 쿼리를 만들 때도 Order의 FK인 MEMBER_ID에서 쿼리를 시작함

# 6강 - 다양한 연관관계

- 연관관계 매핑시 고려사항 3가지
    - 다중성
    - 단방향, 양방향
    - 연관관계의 주인

- 다중성 : db관점에서의 다중성을 기준으로 고민하면 됨 , 헷갈리면 반대로 생각해보셈
    - 다대일: @ManyToOne - 가장 많이 씀
    - 일대다 : @OneToMany
    - 일대일 : @OneToOne
    - 다대다 : @ManyToMany - 실무에서 쓰면 안됨

- 단방향 , 양방향
    - 테이블
        - 외래 키 하나로 양쪽에서 조인 가능 , 방향이라는 개념이 없음
    - 객체
        - 참조용 필드가 있어야 있는 쪽으로만 참조 가능 - 예를들어 멤버에서 팀이 있는데 멤버에서 안에 팀으로 가는 참조가 있어야함
        - 한쪽만 참조하면 단방향
        - 양쪽이 서로 참조하면 양방향 - 양방향이라는 게 없음 객체 입장에서는 방향이 한개임 단방향이 2개 있는거임
        

- 연관관계의 주인
    - 테이블은 외래 키 하나로 두 테이블이 연관관계를 맺음
    - 객체 양방향 관계는 A->B, B->A 처럼 참조가 2군데 - 둘 중 하나에서 외래 키 관리할 곳을 지정해야함
    - 연관관계의 주인 : 둘 중의 외래 키를 관리하는 참조
    - 주인의 반대편: 외래키의 값을 update하는 영향을 주지 않고 단순히 조회만 가능함
    
    ### 다대일 단방향(JPA에서 가장 많이 사용함)
    
    - 일대다 중에 다 쪽에 외래 키가 가야함
    - 외래키가 있는 걸 기준으로 거기에다가 연관된 참조를 넣어주면 됨
    - 가장 많이 사용
    
    다대일 양방향 ( 다가 먼저 나오니까 다가 연관관계의 주인)
    
    - 반대쪽 사이드에서 추가한다고 해서 테이블에 영향을 주지 않음 member가 연관관계의 주인이기 때문에
    - mappedBy =”변수명” 넣어줘야함 여기서는 Team team의 team
    
    - 외래키가 있는 쪽이 연관관계의 주인
    - 양쪽을 서로 참조하도록 개발
    
    ### 일대다 단방향 - 권장하지는 않음
    
    - 무조건 member쪽에(다: N) 외래키가 들어감( Team에 참조가 있는 경우)
    - 일대다에서 일이 연관관계의 주인임(일 방향에서 외래 키를 관리하겠다는거임)
        - Team은 Member를 알고 싶은데 Member은 Team을 알고 싶지 않은거임
        - DB입장에서는 무조건 ‘다’쪽에 외래 키가 들어가야함
        - Team에서 List members를 바꿨을 때, MEMBER의 TEAM_ID(FK)를 업데이트 처리해줘야함(업데이트 쿼리가 추가로 나감)
    - 객체와 테이블의 차이 때문에 반대편 테이블의 외래 키를 관리하는 특이한 구조
    - @JoinColumn을 꼭 사용해야함 (안넣으면 디폴트인 join table이 사용됨→중간 테이블이 생성됨)
    
    **일대다 단방향 정리**
    
    - 엔티티가 관리하는 외래 키가 다른 테이블에 있음
    - 연관관계 관리를 위해 추가로 UPDATE SQL 실행
    
    ### →일대다 단방향 매핑보다는 다대일 양방향 매핑을 사용하자
    
    ### 일대다 양방향
    
    - 이런 매핑이 공식적으로 존재하지는 않음
    
    ```java
    @JoinColumn(insertable=false, updatable=false) 
    //이걸 넣어줌 , 읽기 전용, 최종적으로 INSERT를 UPDATE를 안함
    ```
    
    - 관리는 Team이 하고 Member는 읽기만 하는,,,
    - 읽기 전용 필드를 사용해서 양방향 처럼 사용하는 방법
    - **다대일 양방향 사용하기**
    
    ### 일대다[1:N]
    
    - 1이 연관관계의 주인
    
    일대다 단방향
    
    - 이 모델은 권장하지는 않음 실무에서는 거의 쓰지 않음
    - 테이블에서 무조건 ‘다’쪽에 외래키가 들어감
    - ‘다’쪽에 외래키가 들어가기때문에 Team에서 insert를 하면 쿼리가 MEMBER 테이블에서 한번 더 나감(성능상 큰 문제는 없음)
        - 객체와 테이블의 차이 때문에 반대편 테이블의 외래키를 관리하는 특이한 구조
    - `@JoinColumn` 을 꼭 사용해야 함. 그렇지 않으면 조인 테이블 방식을 사용함( JPA가 중간에 테이블을 하나 추가함)
    
    일대다 양방향
    
    - 야매로 됨
    
    ```java
    @ManyToOne
    @JoinColumn(insertable = false,update = false)
    ```
    
    - 읽기 전용으로 만들어주는거임
    - Team 객체의 List members가 연관관계의 주인으로서 계속 행사를 하고 Member에 있는 Team team도 연관관계의 주인처럼 만들었는데 읽기 전용으로 만든거임 →사실상 양방향 맵핑처럼 되는거임
    
    일대일 관계
    
    - 일대일 관계는 그 반대도 일대일
    - 주 테이블이나  대상 테이블 중에 외래 키 선택 가능 (대칭적)
        - 주 테이블에 외래 키
        - 대상 테이블에 외래 키
    - 외래 키에 데이터베이스 유니크(UNI) 제약조건 추가
    
    일대일: 대상 테이블에 외래 키 단방향
    
    - Member 객체가 반대쪽 사이드에 있는(LOCKER)에 있는 MEMBER_ID를 관리할 수 있느냐? - 안됨 지원도 안되고 방법도 없음
    - 양방향에서는 지원을 해주긴 함
    
    - 강사 본인은 보통 Member에서 Locker locker을 가지고 가게 함
    
    ### 일대일 정리
    
    - 주 테이블에 외래키
        - 주 객체가 대상 객체의 참조를 가지는 것처럼
        주 테이블에 외래 키를 두고 대상 테이블을 찾음
        - 객체지향 개발자 선호
        - JPA 매핑 편리
        - 장점 : 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능
        - 단점 : 값이 없으면 외래 키에 `null` 허용 (치명적)
    
    - 대상 테이블에 외래 키
        - 대상 테이블에 외래 키가 존재
        - 전통적인 데이터베이스 개발자 선호
        - 장점: 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지
        - 단점: 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩됨
        
    - 실무에서는 거의 일대일: 주 테이블에 외래 키 단방향을 씀(싫어하는 사람이 있을 수도 있음)
    
    ### 다대다 - 실무에서는 거의 안 씀
    
    - 관계형 데이터베이스는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없음
    - 연결 테이블을 추가해서 일대다, 다대일 관계로 풀어내야함
    - 객체는 컬렉션을 사용해서 객체 2개로 다대다 관계 가능
    - 다대다 매핑의 한계
        - 편리해 보이지만 실무에서 사용할 수 없음
        - 연결 테이블이 단순히 연결만 하고 끝나지 않음
        - 중간 테이블이 숨겨져 있어서 쿼리가 이상하게 나감
    - 다대다 한계 극복
        - 연결 테이블용 엔티티 추가(연결 테이블을 엔티티로 승격)
        - `@ManyToOne` → `@OneToMany` ,`@ManyToOne`
    - 의미없는 값을 pk로 잡아서 하면 jpa 매핑도 심플하고 개발할 때도 필요한 거 묶어서 제약조건 따는 게 애플리케이션 개발할 때 더 쉬웠음